import { Coord, PieceState, Player, } from "../resources/types";
import { produce, } from 'immer';
import { operations, Piece, } from "../resources/pieces";

type Board = PieceState['board'];

interface Checks {
	pre?: (board:Board, q:number,r:number)=>boolean,
	post?: (board:Board, q:number,r:number)=>boolean,
	stopped?: ()=>boolean,
}

/**
 * iterates the reducer over all tiles reached
 * by the piece on the given starting position
 * @param board The board which is iterated over. Can be the actual board or a temporary board generated by immer.
 * @param start Starting position
 * @param reducer Reducing function
 * @param initial Starting value to accumulate
 * @param check Check to stop iteration at various points
 * @returns Accumulated result from reducer
 */
function range<T> (board:Board, start:Coord, reducer:(prev:T,pos:Coord)=>T, initial:T, checks?:Checks, piece?:Piece) {
	const [q, r] = start;
	piece = piece ?? board[q][r]!;
	if (!piece)
		throw new Error('');

	return operations
		.moves(piece)
		.flatMap(p => {
			const {vectors, rep} = ijk(p);

			return vectors.map(vector => ({vector, rep}))
		})
		.reduce((prev, {vector:[dq,dr], rep}) => {
			if (checks?.stopped?.())
				return prev;
			if (piece!.owner === Player.gyoku)
				{dq = -dq; dr = -dr;}

			const loop = (prev:T, [nq,nr]:Coord,step:number):T => {
				if (!(step < rep) || oob(nq,nr) || checks?.pre?.(board,nq,nr))
					return prev;

				const next = reducer(prev, [nq,nr]);

				if (checks?.post?.(board,nq,nr))
					return next;
				else
					return loop(next,[nq+dq,nr+dr],step+1);
			}

			return loop(prev, [q+dq,r+dr], 0);
			
		}, initial);
}

export function territory (board:Board, start:Coord, oute:boolean, turn:[Player,Player], players:PieceState['players']) {
	const [current, opposing] = turn;
	const [sq, sr] = start;
	const piece = board[sq][sr]!;
	const king = ['O','G'].includes(piece.type);

	return range(board, start, (prev, pos) => produce(prev, prev => {
		prev.push(pos);
	}), [] as Coord[], {
		pre: (board, q, r) => {
			return board[q][r]?.owner === current ||
			((king || oute) && outeCheck(king? [q,r]: players[current].king, players[opposing], produce(board, board => {
				board[q][r] = piece;
				board[sq][sr] = null;
			}), true).length > 0);
		},
		post: (board, q, r) =>Â {
			return board[q][r] !== null;
		}
	})
	
}

export function blocked (board:Board, [q,r]:Coord, piece:Piece) {
	var stopped = {flag: false};

	return range(board, [q,r], () => {
		// some tile reached, not blocked yet
		stopped.flag = true;
		return false;

	}, true, {
		post: (board,q,r) => board[q][r] !== null,
		stopped: () => stopped.flag
	}, piece);
}

export function touches (board:Board, [q,r]:Coord, tile:Coord) {
	const [tq, tr] = tile;
	var stopped = {flag: false};

	return range(board, [q,r], (_,[q,r]) => {
		if (q === tq && r === tr) {
			stopped.flag = true;
			return true;
		}

		return false;
	}, false, {
		post: (board, q, r) => board[q][r] !== null || stopped.flag,
		stopped: () => stopped.flag,
	});
}

export function outeCheck (pos:Coord, opponent:PieceState['players'][0], board:PieceState['board'], thorough:boolean=true) {
	
	return opponent.board
		.filter(([q,r]) => 
			(thorough
			|| operations.moves(board[q][r]!).some(s => s.endsWith('+')))
			&& touches(board, [q,r], pos));
}



function oob(q: number, r: number) {
	return (Math.abs(q) > 5
		|| Math.abs(r) > 5
		|| Math.abs(q + r) > 5)
}

function ijk(move: string): {vectors: Coord[], rep: number, } {
	let d: Coord = [0, 0],
		dx: Coord[] | undefined,
		inc = 1,
		rep = 1,
		number = '';
	for (let c of move) {
		switch (c) {
			case 'i':
				d[1] -= inc;
				break;
			case 'j':
				d[0] += inc;
				break;
			case 'k':
				d[0] -= inc; d[1] += inc;
				break;
			case 'h':
				let [dq, dr] = d;
				let ds = -(dq + dr);

				dx = [
					[dq, dr],
					[-ds, -dq],
					[dr, ds],
					[-dq, -dr],
					[ds, dq],
					[-dr, -ds]
				];
				break;
			case '-':
				inc = -1;
				continue;
			case '+':
				rep = Infinity;
				break;
			case 'f': break;
			default:
				if (c.match(/\d/)) {
					number += c;
					break;
				}
				throw new Error('Invalid char in move string');
		}

		inc = 1;
	}

	if (dx === undefined)
		dx = [d];
	if (number.match(/\d+/))
		rep = Number(number);

	return {vectors:dx, rep, };
}

export function placable (board:PieceState['board'], predicate:(pos:Coord)=>boolean) {
	return Object.entries(board).flatMap(([q, col]) =>
		Object.entries(col).map(([r, piece]) => 
			piece? null:[q, r] as Coord
		).filter((pos):pos is Coord => !!pos)
	).filter(pos => predicate(pos));
}
